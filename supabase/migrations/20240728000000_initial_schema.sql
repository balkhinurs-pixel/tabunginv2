-- Create users table
create table public.users (
  id uuid not null primary key,
  full_name text,
  avatar_url text,
  billing_address jsonb,
  payment_method jsonb
);

-- Create profiles table
create table public.profiles (
  id uuid not null primary key references auth.users on delete cascade,
  email text,
  plan text not null default 'TRIAL'
);

alter table public.users
  enable row level security;
alter table public.profiles
  enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );


-- Create students table
create table public.students (
    id uuid not null default gen_random_uuid() primary key,
    user_id uuid references auth.users on delete cascade,
    nis text not null,
    name text not null,
    class text not null,
    whatsapp_number text,
    created_at timestamptz not null default now(),
    unique (user_id, nis)
);

alter table public.students
  enable row level security;

create policy "Students are viewable by the user who created them."
  on students for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own students."
  on students for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own students."
  on students for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own students."
  on students for delete
  using ( auth.uid() = user_id );


-- Create transactions table
create table public.transactions (
    id uuid not null default gen_random_uuid() primary key,
    student_id uuid not null references public.students on delete cascade,
    user_id uuid references auth.users on delete cascade,
    type text not null check (type in ('Pemasukan', 'Pengeluaran')),
    amount numeric not null,
    description text not null,
    created_at timestamptz not null default now()
);

alter table public.transactions
  enable row level security;

create policy "Transactions are viewable by the user who created them."
  on transactions for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own transactions."
  on transactions for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own transactions."
  on transactions for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own transactions."
  on transactions for delete
  using ( auth.uid() = user_id );


-- Create activation codes table
create table public.activation_codes (
    id bigint generated by default as identity primary key,
    code text not null unique,
    created_at timestamptz not null default now(),
    is_used boolean not null default false,
    used_by uuid references auth.users,
    used_at timestamptz
);

alter table public.activation_codes
  enable row level security;

create policy "Allow admin full access" 
  on activation_codes 
  for all 
  using ( (select role from public.profiles where id = auth.uid()) = 'ADMIN' );


-- Function to activate account
create or replace function activate_account(p_code text, p_user_id uuid)
returns table (id uuid, email text, plan text) as $$
begin
  -- Check if code is valid and not used
  if exists (select 1 from public.activation_codes where code = p_code and is_used = false) then
    -- Update profile to PRO
    update public.profiles
    set plan = 'PRO'
    where public.profiles.id = p_user_id;

    -- Mark code as used
    update public.activation_codes
    set 
      is_used = true,
      used_by = p_user_id,
      used_at = now()
    where code = p_code;

    -- Return the updated profile
    return query select * from public.profiles where public.profiles.id = p_user_id;
  else
    raise exception 'Invalid or already used activation code';
  end if;
end;
$$ language plpgsql security definer;


-- Set up Realtime
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table students;
alter publication supabase_realtime add table transactions;
alter publication supabase_realtime add table profiles;

-- Inserts a row into public.profiles on new user signup
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;
  
-- Trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
