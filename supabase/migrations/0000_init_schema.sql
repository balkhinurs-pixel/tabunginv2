-- ------------------------------------------------
-- 1. PROFILES TABLE
-- Stores user-specific data (non-auth)
-- ------------------------------------------------
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email text,
    plan text DEFAULT 'TRIAL'::text NOT NULL,
    role text DEFAULT 'USER'::text NOT NULL,
    school_name text,
    school_code text,
    CONSTRAINT profiles_school_code_key UNIQUE (school_code)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, role)
  VALUES (
    new.id,
    new.email,
    -- Check if email matches admin pattern
    CASE
      WHEN new.email LIKE '%@admin.com' THEN 'ADMIN'::text
      ELSE 'USER'::text
    END
  );
  RETURN new;
END;
$$;
-- Trigger to call the function when a new user signs up
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
-- ------------------------------------------------
-- 2. STUDENTS TABLE
-- Stores student information, linked to a user (teacher/admin)
-- ------------------------------------------------
CREATE TABLE public.students (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    nis text NOT NULL,
    name text NOT NULL,
    class text NOT NULL,
    whatsapp_number text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT students_nis_user_id_key UNIQUE (nis, user_id) -- NIS should be unique per teacher
);
ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Students are viewable by the user who created them." ON public.students FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Students can be inserted by authenticated users." ON public.students FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Students can be updated by the user who created them." ON public.students FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Students can be deleted by the user who created them." ON public.students FOR DELETE USING (auth.uid() = user_id);
CREATE POLICY "Students can view their own profile." ON public.students FOR SELECT USING (auth.uid() = id);
-- ------------------------------------------------
-- 3. TRANSACTIONS TABLE
-- Stores all financial transactions for students
-- ------------------------------------------------
CREATE TABLE public.transactions (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    student_id uuid NOT NULL REFERENCES public.students(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type text NOT NULL,
    amount numeric NOT NULL,
    description text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Transactions are viewable by the user who created them." ON public.transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Transactions can be inserted by authenticated users." ON public.transactions FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Transactions can be deleted by the user who created them." ON public.transactions FOR DELETE USING (auth.uid() = user_id);
CREATE POLICY "Students can view their own transactions." ON public.transactions FOR SELECT USING (auth.uid() = student_id);
-- ------------------------------------------------
-- 4. ACTIVATION_CODES TABLE
-- Stores codes for upgrading to PRO plan
-- ------------------------------------------------
CREATE TABLE public.activation_codes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    is_used boolean DEFAULT false NOT NULL,
    used_at timestamp with time zone,
    used_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    CONSTRAINT activation_codes_code_key UNIQUE (code)
);
ALTER TABLE public.activation_codes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Activation codes are viewable by ADMIN role." ON public.activation_codes FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'ADMIN'::text);
CREATE POLICY "Activation codes can be created by ADMIN role." ON public.activation_codes FOR INSERT WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'ADMIN'::text);
CREATE POLICY "Activation codes can be used by any authenticated user." ON public.activation_codes FOR SELECT USING (auth.role() = 'authenticated');
-- ------------------------------------------------
-- 5. RPC FUNCTION: activate_account
-- Securely activates a PRO account and marks the code as used.
-- ------------------------------------------------
CREATE OR REPLACE FUNCTION public.activate_account(p_code text, p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_code_id bigint;
  v_is_used boolean;
BEGIN
  -- Check if the code exists and is not used, and lock the row
  SELECT id, is_used INTO v_code_id, v_is_used
  FROM public.activation_codes
  WHERE code = p_code
  FOR UPDATE;
  
  -- If code is not found or already used, raise an exception
  IF NOT FOUND OR v_is_used THEN
    RAISE EXCEPTION 'invalid_or_used_code';
  END IF;
  
  -- Update the user's profile to PRO
  UPDATE public.profiles
  SET plan = 'PRO'
  WHERE id = p_user_id;
  
  -- Mark the code as used
  UPDATE public.activation_codes
  SET 
    is_used = true,
    used_at = now(),
    used_by = p_user_id
  WHERE id = v_code_id;
END;
$$;
