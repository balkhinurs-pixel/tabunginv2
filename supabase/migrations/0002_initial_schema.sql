-- Drop existing policies to avoid conflicts
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can view students in their own school" ON public.students;
DROP POLICY IF EXISTS "Users can manage students in their own school" ON public.students;
DROP POLICY IF EXISTS "Users can view transactions in their own school" ON public.transactions;
DROP POLICY IF EXISTS "Users can manage transactions in their own school" ON public.transactions;
DROP POLICY IF EXISTS "Users can view their own activation codes" ON public.activation_codes;
DROP POLICY IF EXISTS "Admins can manage activation codes" ON public.activation_codes;


-- Create profiles table
create table if not exists public.profiles (
  id uuid not null references auth.users on delete cascade,
  email text,
  plan text default 'TRIAL'::text,
  role text default 'USER'::text,
  school_name text,
  school_code text,
  primary key (id),
  unique (school_code)
);
comment on table public.profiles is 'Stores user profile information, including plan, role, and school details.';

-- Create students table
create table if not exists public.students (
  id uuid not null,
  nis text not null,
  name text not null,
  class text not null,
  whatsapp_number text,
  created_at timestamp with time zone default now(),
  user_id uuid references public.profiles,
  primary key (id),
  unique (nis, user_id)
);
comment on table public.students is 'Stores student information, linked to a user/school profile.';

-- Create transactions table
create table if not exists public.transactions (
  id uuid not null default gen_random_uuid(),
  created_at timestamp with time zone default now(),
  type text not null,
  description text not null,
  amount real not null,
  student_id uuid not null references public.students on delete cascade,
  user_id uuid not null references public.profiles,
  primary key (id)
);
comment on table public.transactions is 'Stores all financial transactions for each student.';

-- Create activation_codes table
create table if not exists public.activation_codes (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  code text not null,
  is_used boolean not null default false,
  used_by uuid,
  used_at timestamp with time zone,
  primary key (id),
  unique (code)
);
comment on table public.activation_codes is 'Stores activation codes for PRO accounts.';


-- Create RPC function to activate account
create or replace function public.activate_account(p_code text, p_user_id uuid)
returns void as $$
declare
  code_id bigint;
begin
  -- Find the code and lock the row
  select id into code_id from public.activation_codes where code = p_code and not is_used for update;

  -- If code is not found or already used, raise an exception
  if code_id is null then
    raise exception 'invalid_or_used_code';
  end if;

  -- Mark the code as used
  update public.activation_codes
  set 
    is_used = true,
    used_by = p_user_id,
    used_at = now()
  where id = code_id;

  -- Upgrade the user's plan to PRO
  update public.profiles
  set plan = 'PRO'
  where id = p_user_id;
end;
$$ language plpgsql;
comment on function public.activate_account is 'Activates a user account to PRO plan using an activation code.';

-- Set up Row Level Security (RLS)
alter table public.profiles enable row level security;
alter table public.students enable row level security;
alter table public.transactions enable row level security;
alter table public.activation_codes enable row level security;

-- RLS Policies for PROFILES table
create policy "Users can view their own profile"
  on public.profiles for select
  using ( auth.uid() = id );

create policy "Users can update their own profile"
  on public.profiles for update
  using ( auth.uid() = id );

-- RLS Policies for STUDENTS table
create policy "Users can manage students they created"
  on public.students for all
  using ( auth.uid() = user_id );

create policy "Students can view their own data"
  on public.students for select
  using ( auth.uid() = id );

-- RLS Policies for TRANSACTIONS table
create policy "Users can manage transactions for their students"
  on public.transactions for all
  using (
    auth.uid() = user_id
  );

create policy "Students can view their own transactions"
  on public.transactions for select
  using (
    auth.uid() = student_id
  );

-- RLS Policies for ACTIVATION_CODES table
create policy "Admins can manage activation codes"
  on public.activation_codes for all
  using ( (select role from public.profiles where id = auth.uid()) = 'ADMIN' );
  
create policy "Authenticated users can read activation codes"
  on public.activation_codes for select
  using ( auth.role() = 'authenticated' );

-- Insert initial data for user profile on new user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to call handle_new_user on new user signup
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Seed an admin user (replace with your admin's details)
-- Example: Making a user with a specific email an ADMIN
-- Make sure this user already exists in auth.users
-- UPDATE public.profiles SET role = 'ADMIN' WHERE email = 'your-admin-email@example.com';
